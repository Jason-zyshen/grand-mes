type Query {
  listNextTask: [ProcedureTask!]!
    @cypher(
      statement: """
      MATCH (t:ProcedureTask {is_completed: false})
      WHERE NOT (t)<-[:NEXT]-(:ProcedureTask {is_completed: false})
      RETURN t
      """
    )
}

type Mutation {
  CreateBOM(
    productName: String!
    BOMName: String!
    bomDetail: [_BOMDetail]!
  ): BOM!
    @cypher(
      statement: """
      UNWIND $bomDetail AS detail
      MATCH (product:Material{name: $productName})
      MATCH (material:Material {name: detail.name})
      MERGE (bom:BOM {name: $BOMName})
       ON CREATE SET bom.id = apoc.create.uuid()
      MERGE (product)-[:HAS_BOM]->(bom)
      MERGE (bom)-[:USES_MATERIAL {amount: detail.amount}]->(material)
      RETURN bom
      """
    )

  CreateCraft(
    productName: String!
    craftName: String!
    craftDetail: [_craftDetail!]!
  ): Craft!
    @cypher(
      statement: """
      // Create a craft.
      MATCH (product:Material{name: $productName})
      MERGE (craft:Craft {name: $craftName})
        ON CREATE SET craft.id = apoc.create.uuid()
      MERGE (product)-[:HAS_CRAFT]->(craft)
      WITH craft

      // Add procedures to craft with order.
      MATCH (first:Procedure {name: $craftDetail[0].name})
      MATCH (last:Procedure {name: $craftDetail[-1].name})
      MERGE (craft)-[:HAS_PROCEDURE {is_first: true}]->(first)
      MERGE (craft)-[:HAS_PROCEDURE {is_last: true}]->(last)
      WITH craft

      UNWIND $craftDetail AS detail
      MATCH (procedure:Procedure {name: detail.name})
      WHERE detail.next IS NOT NULL
      MATCH (next:Procedure {name: detail.next})
      MERGE (procedure)-[:NEXT {craft: craft.name}]->(next)
      MERGE (craft)-[:HAS_PROCEDURE]->(procedure)

      // TODO: return null when given one procedure.
      RETURN craft
      """
    )

  CreateOrder(
    productName: String!
    productAmount: Int!
    deadline: String!
    craftName: String!
  ): WorkOrder!
    @cypher(
      statement: """
      // Create an order.
      MATCH (product:Material{name: $productName})
      MERGE (order:WorkOrder {id: apoc.create.uuid()})
        ON CREATE SET order.is_completed = false, order.deadline = $deadline
      MERGE (product)<-[:HAS_PRODUCT {amount: $productAmount}]-(order)
      WITH order

      // Create tasks from craft.
      MATCH (craft:Craft {name: $craftName})-[:HAS_PROCEDURE]->(procedure:Procedure)
      MERGE (order)-[:USES_CRAFT]->(craft)
      MERGE (procedure)<-[:USES_PROCEDURE]-(task:ProcedureTask {id: apoc.create.uuid()})
        ON CREATE SET task.name = procedure.name, task.is_completed = false, task.amount = $productAmount
      MERGE (order)-[:HAS_TASK]->(task)
      WITH order, task, craft

      // Add first and last mark.
      MATCH (craft)-[:HAS_PROCEDURE {is_first: true}]->(:Procedure)<-[:USES_PROCEDURE]-(first:ProcedureTask)<-[:HAS_TASK]-(order)
      MATCH (craft)-[:HAS_PROCEDURE {is_last: true}]->(:Procedure)<-[:USES_PROCEDURE]-(last:ProcedureTask)<-[:HAS_TASK]-(order)
      MERGE (order)-[ft:HAS_TASK]->(first)
      SET ft.is_first = true
      MERGE (order)-[lt:HAS_TASK]->(last)
      SET lt.is_last = true
      WITH order, task

      // Add order to tasks.
      MATCH (task)-[:USES_PROCEDURE]->(:Procedure)-[:NEXT]->(:Procedure)<-[:USES_PROCEDURE]-(nextTask:ProcedureTask)<-[:HAS_TASK]-(order)
      MERGE (task)-[:NEXT]->(nextTask)

      RETURN order
      """
    )

  ExecuteTask(
    userName: String!
    taskId: String!
    amount: Int!
    time: String!
  ): Boolean
    @cypher(
      statement: """
      // Execute a task.
      MATCH (user: User {name: $userName})
      OPTIONAL MATCH (task: ProcedureTask {id: $taskId, is_completed: false})
      MERGE (user)-[:EXECUTES {at_time: $time, amount: $amount}]->(task)
      WITH task

      // Complete a task if the required amount is finished.
      MATCH (task)<-[exe:EXECUTES]-(:User)
      WITH task, sum(exe.amount) AS completedAmount
      WHERE completedAmount >= task.amount
      SET task.is_completed = true
      WITH task

      // Complete an order if the last task is completed.
      MATCH (task)<-[h:HAS_TASK]-(order:WorkOrder)
      WHERE NOT (task)-[:NEXT]->() AND task.is_completed = true
      SET order.is_completed = true
      RETURN true
      """
    )
}

type WorkOrder {
  id: ID! @id
  is_completed: Boolean!
  schedule_date: String
  deadline: String
  has_product: [Material] @relation(name: "HAS_PRODUCT", direction: OUT)
  HAS_PRODUCT_rel: [HAS_PRODUCT]
  has_task: [ProcedureTask] @relation(name: "HAS_TASK", direction: OUT)
}

type ProcedureTask {
  id: ID! @id
  name: String!
  is_completed: Boolean!
  amount: Int!
  in_order: WorkOrder! @relation(name: "HAS_TASK", direction: IN)
  uses_procedure: [Procedure] @relation(name: "USES_PROCEDURE", direction: OUT)
  users: [User] @relation(name: "EXECUTES", direction: IN)
}

type User {
  id: ID! @id
  name: String! @unique
  executes: [ProcedureTask] @relation(name: "EXECUTES", direction: OUT)
  EXECUTES_rel: [EXECUTES]
}

type Craft {
  id: ID! @id
  name: String! @unique @search
  uses_bom: [BOM] @relation(name: "USES_BOM", direction: OUT)
  first_procedure: [Procedure]
    @relation(name: "FIRST_PROCEDURE", direction: OUT)
  last_procedure: [Procedure] @relation(name: "LAST_PROCEDURE", direction: OUT)
  has_procedure: [Procedure] @relation(name: "HAS_PROCEDURE", direction: OUT)
  HAS_PROCEDURE_rel: [HAS_PROCEDURE]
  materials: [Material] @relation(name: "HAS_CRAFT", direction: IN)
}

type Procedure {
  id: ID! @id
  name: String! @unique
  next: [Procedure] @relation(name: "NEXT", direction: OUT)
  crafts_first_procedure: [Craft]
    @relation(name: "FIRST_PROCEDURE", direction: IN)
  crafts_last_procedure: [Craft]
    @relation(name: "LAST_PROCEDURE", direction: IN)
  proceduretasks_uses_procedure: [ProcedureTask]
    @relation(name: "USES_PROCEDURE", direction: IN)
  crafts_has_procedure: [Craft] @relation(name: "HAS_PROCEDURE", direction: IN)
}

type Material {
  id: ID! @id
  name: String! @unique
  has_craft: [Craft] @relation(name: "HAS_CRAFT", direction: OUT)
  boms: [BOM] @relation(name: "USES_MATERIAL", direction: IN)
  workorders: [WorkOrder] @relation(name: "HAS_PRODUCT", direction: IN)
}

type BOM {
  id: ID! @id
  name: String! @unique
  uses_material: [Material] @relation(name: "USES_MATERIAL", direction: OUT)
  USES_MATERIAL_rel: [USES_MATERIAL]
  crafts: [Craft] @relation(name: "USES_BOM", direction: IN)
}

type USES_MATERIAL @relation(name: "USES_MATERIAL") {
  from: BOM!
  to: Material!
  amount: Int!
}

type HAS_PRODUCT @relation(name: "HAS_PRODUCT") {
  from: WorkOrder!
  to: Material!
  amount: Int!
}

type EXECUTES @relation(name: "EXECUTES") {
  from: User!
  to: ProcedureTask!
  at_time: String!
  amount: Int!
}

type HAS_PROCEDURE @relation(name: "HAS_PROCEDURE") {
  from: Craft!
  to: Procedure!
  type: String
}

input _BOMDetail {
  name: String!
  amount: Int!
}

input _craftDetail {
  name: String!
  next: String
}
